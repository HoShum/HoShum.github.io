# 《汇编语言》(第4版) 王爽

## 第一章 基础知识

这一章主要介绍了为什么会有汇编语言以及和CPU相关的概念

### 汇编语言的诞生

CPU只能读懂机器语言，而机器语言全是由0和1的二进制构成，这对于程序员来说极不友好，于是诞生了汇编语言；程序员编写汇编程序，再由编译器译码成机器语言

![img](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202307052250384.png)

汇编语言由以下三部分组成：

-   汇编指令：机器码的助记符，有对应的机器码
-   伪指令：没有对应机器码，由编译器执行，计算机不执行
-   其他符号：如+、-、*、/等，由编译器识别，没有对应机器码

### CPU对存储器的读写

一个CPU芯片有非常多的引脚，而这在逻辑上就对应不同的总线，CPU就是通过这些总线跟存储器进行数据的读写

![image-20230705225430825](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202307052254847.png)

下面展示一个CPU从3号存储单元读取数据的过程

<img src="https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202307052255869.png" alt="img" style="zoom:80%;" />

1.  控制总线发出要读取的信号
2.  CPU通过地址线从3号存储单元读取08
3.  CPU通过数据总线把08传送给CPU进行处理

### 存储单元和内存地址空间

逻辑上，存储器被划为为一个个存储单元，每个存储单元的最小单位是**一个字节**

CPU为了能够管理内存，需要对内存进行编号，而这些编号的范围取决于CPU的地址总线宽度

CPU会对系统中各类存储器看成一个整体逻辑上的存储器（包括内存、显存、BIOS ROM等），它们共同构成了内存地址空间（实际上这是操作系统来完成的，专业的说法叫内存的虚拟化，具体可看操作系统导论笔记）

## 第二章 寄存器

 8086CPU一共有14个寄存器，分别是AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW，其中前四个是通用寄存器，用来存放一般数据，其他后文会介绍

### 寄存器的结构

对于8086CPU来说，**所有的寄存器都是16位的**，可以存放两个字节，其中又可以区分为**高位字节和低位字节**，两个字节构成一个**字**。另外，AH和AL又可以分别当做一个**独立**的8位寄存器使用

![img](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202307052259378.png)

由于一个寄存器最多只能存放2个字节的数据，一旦数据超过16位发生进位，那么进位值会被寄存器丢弃，但是CPU并不真的丢弃这个进位值

#### 补充 大端小端

-   大端：低地址放高字节数，高地址放低字节数
-   小端：低地址放低字节数，高地址放高字节数

可以看到，8086CPU采用小端模式

另外说一下，由于有的CPU使用大端存储，有的则用小端存储，那么网络传输时到底如何去判断呢？结论：网络传输中会统一使用小端模式，即当一个大端CPU发送TCP数据之前，会把数据转化为小端模式

### 几条汇编指令

| 指令      | 含义                         | 高级语言描述 |
| --------- | ---------------------------- | ------------ |
| mov ax,18 | 将18送入寄存器ax             | ax = 18      |
| mov ax,bx | 将bx寄存器中的值送入ax寄存器 | ax = bx      |
| add ax,bx | 将bx寄存器的值加到ax寄存器中 | ax += bx     |

>   注意，使用高级语言描述仅仅用作理解

### 物理地址

8086CPU是16位结构的CPU，但是它的地址总线有20位，为了能够表现出**1MB**的寻址能力，采用了一种**使用两个16位地址合成为一个20位地址**的方法，而它的本质是：**采用段地址 \* 16 + 偏移地址**的方式去得到物理地址，这样虽然每次依然只能读取一个段（16位）的数据，但是它总的对内存的寻址能力相当于是提高了

>   实际上，8086CPU是通过两个寄存器的值，经过加法器，来合成出一个20位的地址，而这两个寄存器分别是代码段寄存器CS和指令指针寄存器IP

![img](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202307052258107.png)

地址加法器如何对段地址进行 * 16？

>   对于计算机来说，计算*16是非常简单的，只需要<<4即可

### 段

内存实际上并没有分段，分段是通过CPU，严格来讲是通过程序，我们的代码告诉CPU要从哪一个段开始读取

由于段地址 * 16必然是16的倍数，因此一个段的起始地址也一定是16的倍数

另外，由于8086CPU是16位结构，因此一个段的最大长度是：

![img](https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202307052258242.svg)

### 段寄存器 CS:IP

我们的程序需要告诉CPU从哪个段开始读取，而这就是通过CS（Code Segment）和IP（Instruction Pointer）这两个寄存器来实现；CS寄存器存放的是段地址，IP存放的是偏移地址，**CPU会把CS:IP指向的内存单元中的内容看做指令，换句话说，被CS:IP指向的内存单元，可以看做是代码段**

如何改变CS:IP的值？可以通过`jmp`指令

-   `jmp 段地址:偏移地址`修改相应的段地址值和偏移地址值
-   `jmp 寄存器`仅修改IP的值

**注意，不能使用`mov`指令修改段寄存器的值⚠️**

## 第三章 寄存器（内存访问）

### 数据段寄存器 DS

8086CPU中有一个寄存器`DS`，它的作用是用来读取一个单元内存到寄存器中

使用[...]表示一个内存单元，里面的数字表示内存单元的偏移值；而要获取内存单元的地址，则先要从DS寄存器中获取段地址，再根据偏移值获取内存单元的地址

下面展示把`1000:0`单元的值送到寄存器AX

```asm
mov bx,1000H
mov ds,bx
mov ax,[0]
```

