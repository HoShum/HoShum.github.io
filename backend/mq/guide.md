# MQ篇
下面开始MQ篇的笔记，感觉自己挖了好多坑😂

## MQ 消息队列中间件
相信后端对MQ都不陌生，MQ（Message Queue Middleware），即消息队列中间件，我们来看一下普遍的定义是什么样的：

>   指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信

简单来说，消息队列就是用来通信和交换消息，它不受不同平台的影响，特别适合用于**分布式的环境**

消息队列有哪些优点呢？

-   **项目解耦**：不同的项目或模块可以使用消息中间件进行数据的传递，从而可以保证模块的相对独立性，实现解耦。
-   **流量削峰**：可以将突发的流量 (如秒杀数据) 写入消息中间件，然后由多个消费者进行异步处理。
-   **弹性伸缩**：可以通过对消息中间件进行横向扩展来提高系统的处理能力和吞吐量。
-   **发布订阅**：可以用于任意的发布订阅模式中。
-   **异步处理**：当我们不需要对数据进行立即处理，或者不关心数据的处理结果时，可以使用中间件进行异步处理。
-   **可恢复性**：一旦某个业务系统挂掉，因为MQ的存在，可以等系统恢复后再消费
-   **顺序保证**：大多数场景下，数据的有序非常重要，大部分的MQ都支持一定的顺序性
-   **冗余存储**：消息中间件可以对数据进行持久化存储，直到你消费完成后再进行删除。

但同时，我们也要知道，一旦系统中引入了MQ，也会带来以下问题：

-   架构变得更复杂，增加开发和维护成本
-   消息非常依赖Broker，一旦消息队列系统崩溃，会导致消息丢失、延迟等情况

尽管如此，MQ已经成为了大型分布式系统开发的不可或缺的一部分，因此非常有必要学习🛠️

<img src="https://cdn.jsdelivr.net/gh/HoShum/PictureRepo/imgs/202307151146214.png" alt="image-20230715114600110" style="zoom:50%;" />

## AMQP & MQ & JMS

一说MQ，相信大部分后端都知道，但说起AMQP，可能就没那么熟悉了。

实际上，一开始的MQ是有非常多的标准的，MQ产品的价格也非常高昂，于是后来为了打破壁垒，在2006年6 月，由 Cisco、Redhat、iMatix 等公司联合制定了 AMQP的公开标准，目的就是建立一个统一的开放标准，不受产品、开发等条件的限制

AMQP提供统一消息服务的应用层通讯协议，为消息中间件提供统一的开发规范。不同客户端可以将消息投递到中间件上，或从上面获取消息；发送消息和接收消息的客户端可以采用不同的语言开发、不同的技术实现，但必须遵循相同的 AMQP 协议。AMQP 协议本身包括以下三层：

-   **Module Layer**：位于协议最高层，主要定义了一些供客户端调用的命令，客户端可以利用这些命令实现自己的业务逻辑。例如：可以使用 Queue.Declare 命令声明一个队列或者使用 Basic.Consume 订阅消费一个队列中的消息
-   **Session Layer**：位于中间层，主要负责将客户端的命令发送给服务器，再将服务端的应答返回给客户端，主要为客户端与服务器之间的通信提供可靠性同步机制和错误处理
-   **Transport Layer**：位于最底层，主要传输二进制数据流 ，提供帧的处理、信道复用、错误检测和数据表示等

>   另外提一提JMS（Java Message Service）顾名思义，是一个基于Java的消息通信协议，理论上来说所有的Java程序都可以针对JMS API编程，其中Spring就集成了JMS

## 不同的MQ产品

市面上的MQ产品非常多，常见的有：

-   ActiveMQ 
-   RabbitMQ
-   RocketMQ
-   Kafka

一般来说只要学习后三种即可，而且其实他们的概念都差不多，学完一个再学另一个是非常轻松的

下面来对比一下不同的MQ产品

|            | **RabbitMQ**            | **RocketMQ** | **Kafka**  | **ActiveMQ**                   |
| ---------- | ----------------------- | ------------ | ---------- | :----------------------------- |
| 公司/社区  | Rabbit                  | 阿里         | Apache     | Apache                         |
| 开发语言   | Erlang                  | Java         | Scala&Java | Java                           |
| 协议支持   | AMQP，XMPP，SMTP，STOMP | 自定义协议   | 自定义协议 | OpenWire,STOMP，REST,XMPP,AMQP |
| 可用性     | 高                      | 高           | 高         | 一般                           |
| 单机吞吐量 | 一般                    | 高           | 非常高     | 差                             |
| 消息延迟   | 微秒级                  | 毫秒级       | 毫秒以内   | 毫秒级                         |
| 消息可靠性 | 高                      | 高           | 一般       | 一般                           |

追求可用性：Kafka、 RocketMQ 、RabbitMQ

追求可靠性：RabbitMQ、RocketMQ

追求吞吐能力：RocketMQ、Kafka

追求消息低延迟：RabbitMQ、Kafka

## RabbitMQ 🐰

RabbitMQ是完全遵循AMQP的实现，它的名字也很有意思，寓意是希望像兔子🐰一样繁殖快速（不知道大家有没有听过澳大利亚兔子疯狂生长的故事T-T）

-   [RaabitMQ入门学习笔记](./rabbitmq/01入门.md)

## RocketMQ 🚀

待定...



## Kafka 🌊

为什么用海？因为看到卡夫卡就想起了村上春树的《海边的卡夫卡》😂

待定...